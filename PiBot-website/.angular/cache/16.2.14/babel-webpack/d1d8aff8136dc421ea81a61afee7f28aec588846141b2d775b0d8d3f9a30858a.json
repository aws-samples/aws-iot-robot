{"ast":null,"code":"var AWS = require('../core');\n\n/**\n * @api private\n */\nvar service = null;\n\n/**\n * @api private\n */\nvar api = {\n  signatureVersion: 'v4',\n  signingName: 'rds-db',\n  operations: {}\n};\n\n/**\n * @api private\n */\nvar requiredAuthTokenOptions = {\n  region: 'string',\n  hostname: 'string',\n  port: 'number',\n  username: 'string'\n};\n\n/**\n * A signer object can be used to generate an auth token to a database.\n */\nAWS.RDS.Signer = AWS.util.inherit({\n  /**\n   * Creates a signer object can be used to generate an auth token.\n   *\n   * @option options credentials [AWS.Credentials] the AWS credentials\n   *   to sign requests with. Uses the default credential provider chain\n   *   if not specified.\n   * @option options hostname [String] the hostname of the database to connect to.\n   * @option options port [Number] the port number the database is listening on.\n   * @option options region [String] the region the database is located in.\n   * @option options username [String] the username to login as.\n   * @example Passing in options to constructor\n   *   var signer = new AWS.RDS.Signer({\n   *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\n   *     region: 'us-east-1',\n   *     hostname: 'db.us-east-1.rds.amazonaws.com',\n   *     port: 8000,\n   *     username: 'name'\n   *   });\n   */\n  constructor: function Signer(options) {\n    this.options = options || {};\n  },\n  /**\n   * @api private\n   * Strips the protocol from a url.\n   */\n  convertUrlToAuthToken: function convertUrlToAuthToken(url) {\n    // we are always using https as the protocol\n    var protocol = 'https://';\n    if (url.indexOf(protocol) === 0) {\n      return url.substring(protocol.length);\n    }\n  },\n  /**\n   * @overload getAuthToken(options = {}, [callback])\n   *   Generate an auth token to a database.\n   *   @note You must ensure that you have static or previously resolved\n   *     credentials if you call this method synchronously (with no callback),\n   *     otherwise it may not properly sign the request. If you cannot guarantee\n   *     this (you are using an asynchronous credential provider, i.e., EC2\n   *     IAM roles), you should always call this method with an asynchronous\n   *     callback.\n   *\n   *   @param options [map] The fields to use when generating an auth token.\n   *     Any options specified here will be merged on top of any options passed\n   *     to AWS.RDS.Signer:\n   *\n   *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\n   *         to sign requests with. Uses the default credential provider chain\n   *         if not specified.\n   *     * **hostname** (String) &mdash; the hostname of the database to connect to.\n   *     * **port** (Number) &mdash; the port number the database is listening on.\n   *     * **region** (String) &mdash; the region the database is located in.\n   *     * **username** (String) &mdash; the username to login as.\n   *   @return [String] if called synchronously (with no callback), returns the\n   *     auth token.\n   *   @return [null] nothing is returned if a callback is provided.\n   *   @callback callback function (err, token)\n   *     If a callback is supplied, it is called when an auth token has been generated.\n   *     @param err [Error] the error object returned from the signer.\n   *     @param token [String] the auth token.\n   *\n   *   @example Generating an auth token synchronously\n   *     var signer = new AWS.RDS.Signer({\n   *       // configure options\n   *       region: 'us-east-1',\n   *       username: 'default',\n   *       hostname: 'db.us-east-1.amazonaws.com',\n   *       port: 8000\n   *     });\n   *     var token = signer.getAuthToken({\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\n   *       username: 'test' // overriding username\n   *     });\n   *   @example Generating an auth token asynchronously\n   *     var signer = new AWS.RDS.Signer({\n   *       // configure options\n   *       region: 'us-east-1',\n   *       username: 'default',\n   *       hostname: 'db.us-east-1.amazonaws.com',\n   *       port: 8000\n   *     });\n   *     signer.getAuthToken({\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\n   *       username: 'test' // overriding username\n   *     }, function(err, token) {\n   *       if (err) {\n   *         // handle error\n   *       } else {\n   *         // use token\n   *       }\n   *     });\n   *\n   */\n  getAuthToken: function getAuthToken(options, callback) {\n    if (typeof options === 'function' && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n    var self = this;\n    var hasCallback = typeof callback === 'function';\n    // merge options with existing options\n    options = AWS.util.merge(this.options, options);\n    // validate options\n    var optionsValidation = this.validateAuthTokenOptions(options);\n    if (optionsValidation !== true) {\n      if (hasCallback) {\n        return callback(optionsValidation, null);\n      }\n      throw optionsValidation;\n    }\n\n    // 15 minutes\n    var expires = 900;\n    // create service to generate a request from\n    var serviceOptions = {\n      region: options.region,\n      endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\n      paramValidation: false,\n      signatureVersion: 'v4'\n    };\n    if (options.credentials) {\n      serviceOptions.credentials = options.credentials;\n    }\n    service = new AWS.Service(serviceOptions);\n    // ensure the SDK is using sigv4 signing (config is not enough)\n    service.api = api;\n    var request = service.makeRequest();\n    // add listeners to request to properly build auth token\n    this.modifyRequestForAuthToken(request, options);\n    if (hasCallback) {\n      request.presign(expires, function (err, url) {\n        if (url) {\n          url = self.convertUrlToAuthToken(url);\n        }\n        callback(err, url);\n      });\n    } else {\n      var url = request.presign(expires);\n      return this.convertUrlToAuthToken(url);\n    }\n  },\n  /**\n   * @api private\n   * Modifies a request to allow the presigner to generate an auth token.\n   */\n  modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\n    request.on('build', request.buildAsGet);\n    var httpRequest = request.httpRequest;\n    httpRequest.body = AWS.util.queryParamsToString({\n      Action: 'connect',\n      DBUser: options.username\n    });\n  },\n  /**\n   * @api private\n   * Validates that the options passed in contain all the keys with values of the correct type that\n   *   are needed to generate an auth token.\n   */\n  validateAuthTokenOptions: function validateAuthTokenOptions(options) {\n    // iterate over all keys in options\n    var message = '';\n    options = options || {};\n    for (var key in requiredAuthTokenOptions) {\n      if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\n        continue;\n      }\n      if (typeof options[key] !== requiredAuthTokenOptions[key]) {\n        message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\n      }\n    }\n    if (message.length) {\n      return AWS.util.error(new Error(), {\n        code: 'InvalidParameter',\n        message: message\n      });\n    }\n    return true;\n  }\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}