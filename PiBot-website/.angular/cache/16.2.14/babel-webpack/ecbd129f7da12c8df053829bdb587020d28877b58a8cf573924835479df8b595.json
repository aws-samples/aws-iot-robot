{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignalingClient = void 0;\nvar tslib_1 = require(\"tslib\");\nvar events_1 = require(\"events\");\nvar Role_1 = require(\"./Role\");\nvar SigV4RequestSigner_1 = require(\"./SigV4RequestSigner\");\nvar DateProvider_1 = tslib_1.__importDefault(require(\"./internal/DateProvider\"));\nvar utils_1 = require(\"./internal/utils\");\nvar MessageType = /*#__PURE__*/function (MessageType) {\n  MessageType[\"SDP_ANSWER\"] = \"SDP_ANSWER\";\n  MessageType[\"SDP_OFFER\"] = \"SDP_OFFER\";\n  MessageType[\"ICE_CANDIDATE\"] = \"ICE_CANDIDATE\";\n  MessageType[\"STATUS_RESPONSE\"] = \"STATUS_RESPONSE\";\n  return MessageType;\n}(MessageType || {});\nvar ReadyState = /*#__PURE__*/function (ReadyState) {\n  ReadyState[ReadyState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ReadyState[ReadyState[\"OPEN\"] = 1] = \"OPEN\";\n  ReadyState[ReadyState[\"CLOSING\"] = 2] = \"CLOSING\";\n  ReadyState[ReadyState[\"CLOSED\"] = 3] = \"CLOSED\";\n  return ReadyState;\n}(ReadyState || {});\n/**\n * Client for sending and receiving messages from a KVS Signaling Channel. The client can operate as either the 'MASTER' or a 'VIEWER'.\n *\n * Typically, the 'MASTER' listens for ICE candidates and SDP offers and responds with and SDP answer and its own ICE candidates.\n *\n * Typically, the 'VIEWER' sends an SDP offer and its ICE candidates and then listens for ICE candidates and SDP answers from the 'MASTER'.\n */\nvar SignalingClient = /** @class */function (_super) {\n  tslib_1.__extends(SignalingClient, _super);\n  /**\n   * Creates a new SignalingClient. The connection with the signaling service must be opened with the 'open' method.\n   * @param {SignalingClientConfig} config - Configuration options and parameters.\n   * is not provided, it will be loaded from the global scope.\n   */\n  function SignalingClient(config) {\n    var _this = _super.call(this) || this;\n    _this.websocket = null;\n    _this.readyState = ReadyState.CLOSED;\n    _this.pendingIceCandidatesByClientId = {};\n    _this.hasReceivedRemoteSDPByClientId = {};\n    // Validate config\n    (0, utils_1.validateValueNonNil)(config, 'SignalingClientConfig');\n    (0, utils_1.validateValueNonNil)(config.role, 'role');\n    if (config.role === Role_1.Role.VIEWER) {\n      (0, utils_1.validateValueNonNil)(config.clientId, 'clientId');\n    } else {\n      (0, utils_1.validateValueNil)(config.clientId, 'clientId');\n    }\n    (0, utils_1.validateValueNonNil)(config.channelARN, 'channelARN');\n    (0, utils_1.validateValueNonNil)(config.region, 'region');\n    (0, utils_1.validateValueNonNil)(config.channelEndpoint, 'channelEndpoint');\n    _this.config = tslib_1.__assign({}, config); // Copy config to new object for immutability.\n    if (config.requestSigner) {\n      _this.requestSigner = config.requestSigner;\n    } else {\n      (0, utils_1.validateValueNonNil)(config.credentials, 'credentials');\n      _this.requestSigner = new SigV4RequestSigner_1.SigV4RequestSigner(config.region, config.credentials);\n    }\n    _this.dateProvider = new DateProvider_1.default(config.systemClockOffset || 0);\n    // Bind event handlers\n    _this.onOpen = _this.onOpen.bind(_this);\n    _this.onMessage = _this.onMessage.bind(_this);\n    _this.onError = _this.onError.bind(_this);\n    _this.onClose = _this.onClose.bind(_this);\n    return _this;\n  }\n  /**\n   * Opens the connection with the signaling service. Listen to the 'open' event to be notified when the connection has been opened.\n   */\n  SignalingClient.prototype.open = function () {\n    var _this = this;\n    if (this.readyState !== ReadyState.CLOSED) {\n      throw new Error('Client is already open, opening, or closing');\n    }\n    this.readyState = ReadyState.CONNECTING;\n    // The process of opening the connection is asynchronous via promises, but the interaction model is to handle asynchronous actions via events.\n    // Therefore, we just kick off the asynchronous process and then return and let it fire events.\n    this.asyncOpen().then().catch(function (err) {\n      return _this.onError(err);\n    });\n  };\n  /**\n   * Asynchronous implementation of `open`.\n   */\n  SignalingClient.prototype.asyncOpen = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var queryParams, signedURL;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryParams = {\n              'X-Amz-ChannelARN': this.config.channelARN\n            };\n            if (this.config.role === Role_1.Role.VIEWER) {\n              queryParams['X-Amz-ClientId'] = this.config.clientId;\n            }\n            return [4 /*yield*/, this.requestSigner.getSignedURL(this.config.channelEndpoint, queryParams, this.dateProvider.getDate())];\n          case 1:\n            signedURL = _a.sent();\n            // If something caused the state to change from CONNECTING, then don't create the WebSocket instance.\n            if (this.readyState !== ReadyState.CONNECTING) {\n              return [2 /*return*/];\n            }\n            /* istanbul ignore next */\n            this.websocket = new (global.WebSocket || require('ws'))(signedURL);\n            this.websocket.addEventListener('open', this.onOpen);\n            this.websocket.addEventListener('message', this.onMessage);\n            this.websocket.addEventListener('error', this.onError);\n            this.websocket.addEventListener('close', this.onClose);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Closes the connection to the KVS Signaling Service. If already closed or closing, no action is taken. Listen to the 'close' event to be notified when the\n   * connection has been closed.\n   */\n  SignalingClient.prototype.close = function () {\n    if (this.websocket !== null) {\n      this.readyState = ReadyState.CLOSING;\n      this.websocket.close();\n    } else if (this.readyState !== ReadyState.CLOSED) {\n      this.onClose();\n    }\n  };\n  /**\n   * Sends the given SDP offer to the signaling service.\n   *\n   * Typically, only the 'VIEWER' role should send an SDP offer.\n   * @param {RTCSessionDescription} sdpOffer - SDP offer to send.\n   * @param {string} [recipientClientId] - ID of the client to send the message to. Required for 'MASTER' role. Should not be present for 'VIEWER' role.\n   * @param {string} [correlationId] - Unique ID for this message. If this is present and there is an error,\n   * Signaling will send a StatusResponse message describing the error. If this is not present, no error will be returned.\n   */\n  SignalingClient.prototype.sendSdpOffer = function (sdpOffer, recipientClientId, correlationId) {\n    this.sendMessage(MessageType.SDP_OFFER, sdpOffer, recipientClientId, correlationId);\n  };\n  /**\n   * Sends the given SDP answer to the signaling service.\n   *\n   * Typically, only the 'MASTER' role should send an SDP answer.\n   * @param {RTCSessionDescription} sdpAnswer - SDP answer to send.\n   * @param {string} [recipientClientId] - ID of the client to send the message to. Required for 'MASTER' role. Should not be present for 'VIEWER' role.\n   * @param {string} [correlationId] - Unique ID for this message. If this is present and there is an error,\n   * Signaling will send a StatusResponse message describing the error. If this is not present, no error will be returned.\n   */\n  SignalingClient.prototype.sendSdpAnswer = function (sdpAnswer, recipientClientId, correlationId) {\n    this.sendMessage(MessageType.SDP_ANSWER, sdpAnswer, recipientClientId, correlationId);\n  };\n  /**\n   * Sends the given ICE candidate to the signaling service.\n   *\n   * Typically, both the 'VIEWER' role and 'MASTER' role should send ICE candidates.\n   * @param {RTCIceCandidate} iceCandidate - ICE candidate to send.\n   * @param {string} [recipientClientId] - ID of the client to send the message to. Required for 'MASTER' role. Should not be present for 'VIEWER' role.\n   * @param {string} [correlationId] - Unique ID for this message. If this is present and there is an error,\n   * Signaling will send a StatusResponse message describing the error. If this is not present, no error will be returned.\n   */\n  SignalingClient.prototype.sendIceCandidate = function (iceCandidate, recipientClientId, correlationId) {\n    this.sendMessage(MessageType.ICE_CANDIDATE, iceCandidate, recipientClientId, correlationId);\n  };\n  /**\n   * Validates the WebSocket connection is open and that the recipient client id is present if sending as the 'MASTER'. Encodes the given message payload\n   * and sends the message to the signaling service.\n   */\n  SignalingClient.prototype.sendMessage = function (action, messagePayload, recipientClientId, correlationId) {\n    if (this.readyState !== ReadyState.OPEN) {\n      throw new Error('Could not send message because the connection to the signaling service is not open.');\n    }\n    this.validateRecipientClientId(recipientClientId);\n    this.validateCorrelationId(correlationId);\n    this.websocket.send(JSON.stringify({\n      action: action,\n      messagePayload: SignalingClient.serializeJSONObjectAsBase64String(messagePayload),\n      recipientClientId: recipientClientId || undefined,\n      correlationId: correlationId || undefined\n    }));\n  };\n  /**\n   * Removes all event listeners from the WebSocket and removes the reference to the WebSocket object.\n   */\n  SignalingClient.prototype.cleanupWebSocket = function () {\n    if (this.websocket === null) {\n      return;\n    }\n    this.websocket.removeEventListener('open', this.onOpen);\n    this.websocket.removeEventListener('message', this.onMessage);\n    this.websocket.removeEventListener('error', this.onError);\n    this.websocket.removeEventListener('close', this.onClose);\n    this.websocket = null;\n  };\n  /**\n   * WebSocket 'open' event handler. Forwards the event on to listeners.\n   */\n  SignalingClient.prototype.onOpen = function () {\n    this.readyState = ReadyState.OPEN;\n    this.emit('open');\n  };\n  /**\n   * WebSocket 'message' event handler. Attempts to parse the message and handle it according to the message type.\n   */\n  SignalingClient.prototype.onMessage = function (event) {\n    var parsedEventData;\n    var parsedMessagePayload;\n    try {\n      parsedEventData = JSON.parse(event.data);\n    } catch (e) {\n      // For forwards compatibility we ignore messages that are not able to be parsed.\n      // TODO: Consider how to make it easier for users to be aware of dropped messages.\n      return;\n    }\n    try {\n      parsedMessagePayload = SignalingClient.parseJSONObjectFromBase64String(parsedEventData.messagePayload);\n    } catch (e) {\n      // TODO: Consider how to make it easier for users to be aware of dropped messages.\n    }\n    var messageType = parsedEventData.messageType,\n      senderClientId = parsedEventData.senderClientId,\n      statusResponse = parsedEventData.statusResponse;\n    if (!parsedMessagePayload && !statusResponse) {\n      // TODO: Consider how to make it easier for users to be aware of dropped messages.\n      return;\n    }\n    switch (messageType) {\n      case MessageType.SDP_OFFER:\n        this.emit('sdpOffer', parsedMessagePayload, senderClientId);\n        this.emitPendingIceCandidates(senderClientId);\n        return;\n      case MessageType.SDP_ANSWER:\n        this.emit('sdpAnswer', parsedMessagePayload, senderClientId);\n        this.emitPendingIceCandidates(senderClientId);\n        return;\n      case MessageType.ICE_CANDIDATE:\n        this.emitOrQueueIceCandidate(parsedMessagePayload, senderClientId);\n        return;\n      case MessageType.STATUS_RESPONSE:\n        this.emit('statusResponse', statusResponse);\n        return;\n    }\n  };\n  /**\n   * Takes the given base64 encoded string and decodes it into a JSON object.\n   */\n  SignalingClient.parseJSONObjectFromBase64String = function (base64EncodedString) {\n    try {\n      return JSON.parse(atob(base64EncodedString));\n    } catch (e) {\n      return JSON.parse(Buffer.from(base64EncodedString, 'base64').toString());\n    }\n  };\n  /**\n   * Takes the given JSON object and encodes it into a base64 string.\n   */\n  SignalingClient.serializeJSONObjectAsBase64String = function (object) {\n    try {\n      return btoa(JSON.stringify(object));\n    } catch (e) {\n      return Buffer.from(JSON.stringify(object)).toString('base64');\n    }\n  };\n  /**\n   * If an SDP offer or answer has already been received from the given client, then the given ICE candidate is emitted. Otherwise, it is queued up for when\n   * an SDP offer or answer is received.\n   */\n  SignalingClient.prototype.emitOrQueueIceCandidate = function (iceCandidate, clientId) {\n    var clientIdKey = clientId || SignalingClient.DEFAULT_CLIENT_ID;\n    if (this.hasReceivedRemoteSDPByClientId[clientIdKey]) {\n      this.emit('iceCandidate', iceCandidate, clientId);\n    } else {\n      if (!this.pendingIceCandidatesByClientId[clientIdKey]) {\n        this.pendingIceCandidatesByClientId[clientIdKey] = [];\n      }\n      this.pendingIceCandidatesByClientId[clientIdKey].push(iceCandidate);\n    }\n  };\n  /**\n   * Emits any pending ICE candidates for the given client and records that an SDP offer or answer has been received from the client.\n   */\n  SignalingClient.prototype.emitPendingIceCandidates = function (clientId) {\n    var _this = this;\n    var clientIdKey = clientId || SignalingClient.DEFAULT_CLIENT_ID;\n    this.hasReceivedRemoteSDPByClientId[clientIdKey] = true;\n    var pendingIceCandidates = this.pendingIceCandidatesByClientId[clientIdKey];\n    if (!pendingIceCandidates) {\n      return;\n    }\n    delete this.pendingIceCandidatesByClientId[clientIdKey];\n    pendingIceCandidates.forEach(function (iceCandidate) {\n      _this.emit('iceCandidate', iceCandidate, clientId);\n    });\n  };\n  /**\n   * Throws an error if the recipient client id is null and the current role is 'MASTER' as all messages sent as 'MASTER' should have a recipient client id.\n   */\n  SignalingClient.prototype.validateRecipientClientId = function (recipientClientId) {\n    if (this.config.role === Role_1.Role.VIEWER && recipientClientId) {\n      throw new Error('Unexpected recipient client id. As the VIEWER, messages must not be sent with a recipient client id.');\n    }\n  };\n  /**\n   * Throws an error if the correlationId does not fit the constraints mentioned in {@link https://docs.aws.amazon.com/kinesisvideostreams-webrtc-dg/latest/devguide/kvswebrtc-websocket-apis4.html the documentation}.\n   */\n  SignalingClient.prototype.validateCorrelationId = function (correlationId) {\n    if (correlationId && !/^[a-zA-Z0-9_.-]{1,256}$/.test(correlationId)) {\n      throw new Error('Correlation id does not fit the constraint!');\n    }\n  };\n  /**\n   * 'error' event handler. Forwards the error onto listeners.\n   */\n  SignalingClient.prototype.onError = function (error) {\n    this.emit('error', error);\n  };\n  /**\n   * 'close' event handler. Forwards the error onto listeners and cleans up the connection.\n   */\n  SignalingClient.prototype.onClose = function () {\n    this.readyState = ReadyState.CLOSED;\n    this.cleanupWebSocket();\n    this.emit('close');\n  };\n  SignalingClient.DEFAULT_CLIENT_ID = 'MASTER';\n  return SignalingClient;\n}(events_1.EventEmitter);\nexports.SignalingClient = SignalingClient;\n//# sourceMappingURL=SignalingClient.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}