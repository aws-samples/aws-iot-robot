{"ast":null,"code":"/**\n * @file Web Cryptography API shim\n * @author Artem S Vybornov <vybornov@gmail.com>\n * @license MIT\n */\n(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function () {\n      return factory(global);\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    // CommonJS-like environments that support module.exports\n    module.exports = factory(global);\n  } else {\n    factory(global);\n  }\n})(typeof self !== 'undefined' ? self : this, function (global) {\n  'use strict';\n\n  if (typeof Promise !== 'function') throw \"Promise support required\";\n  var _crypto = global.crypto || global.msCrypto;\n  if (!_crypto) return;\n  var _subtle = _crypto.subtle || _crypto.webkitSubtle;\n  if (!_subtle) return;\n  var _Crypto = global.Crypto || _crypto.constructor || Object,\n    _SubtleCrypto = global.SubtleCrypto || _subtle.constructor || Object,\n    _CryptoKey = global.CryptoKey || global.Key || Object;\n  var isEdge = global.navigator.userAgent.indexOf('Edge/') > -1;\n  var isIE = !!global.msCrypto && !isEdge;\n  var isWebkit = !_crypto.subtle && !!_crypto.webkitSubtle;\n  if (!isIE && !isWebkit) return;\n  function s2a(s) {\n    return btoa(s).replace(/\\=+$/, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  }\n  function a2s(s) {\n    s += '===', s = s.slice(0, -s.length % 4);\n    return atob(s.replace(/-/g, '+').replace(/_/g, '/'));\n  }\n  function s2b(s) {\n    var b = new Uint8Array(s.length);\n    for (var i = 0; i < s.length; i++) b[i] = s.charCodeAt(i);\n    return b;\n  }\n  function b2s(b) {\n    if (b instanceof ArrayBuffer) b = new Uint8Array(b);\n    return String.fromCharCode.apply(String, b);\n  }\n  function alg(a) {\n    var r = {\n      'name': (a.name || a || '').toUpperCase().replace('V', 'v')\n    };\n    switch (r.name) {\n      case 'SHA-1':\n      case 'SHA-256':\n      case 'SHA-384':\n      case 'SHA-512':\n        break;\n      case 'AES-CBC':\n      case 'AES-GCM':\n      case 'AES-KW':\n        if (a.length) r['length'] = a.length;\n        break;\n      case 'HMAC':\n        if (a.hash) r['hash'] = alg(a.hash);\n        if (a.length) r['length'] = a.length;\n        break;\n      case 'RSAES-PKCS1-v1_5':\n        if (a.publicExponent) r['publicExponent'] = new Uint8Array(a.publicExponent);\n        if (a.modulusLength) r['modulusLength'] = a.modulusLength;\n        break;\n      case 'RSASSA-PKCS1-v1_5':\n      case 'RSA-OAEP':\n        if (a.hash) r['hash'] = alg(a.hash);\n        if (a.publicExponent) r['publicExponent'] = new Uint8Array(a.publicExponent);\n        if (a.modulusLength) r['modulusLength'] = a.modulusLength;\n        break;\n      default:\n        throw new SyntaxError(\"Bad algorithm name\");\n    }\n    return r;\n  }\n  ;\n  function jwkAlg(a) {\n    return {\n      'HMAC': {\n        'SHA-1': 'HS1',\n        'SHA-256': 'HS256',\n        'SHA-384': 'HS384',\n        'SHA-512': 'HS512'\n      },\n      'RSASSA-PKCS1-v1_5': {\n        'SHA-1': 'RS1',\n        'SHA-256': 'RS256',\n        'SHA-384': 'RS384',\n        'SHA-512': 'RS512'\n      },\n      'RSAES-PKCS1-v1_5': {\n        '': 'RSA1_5'\n      },\n      'RSA-OAEP': {\n        'SHA-1': 'RSA-OAEP',\n        'SHA-256': 'RSA-OAEP-256'\n      },\n      'AES-KW': {\n        '128': 'A128KW',\n        '192': 'A192KW',\n        '256': 'A256KW'\n      },\n      'AES-GCM': {\n        '128': 'A128GCM',\n        '192': 'A192GCM',\n        '256': 'A256GCM'\n      },\n      'AES-CBC': {\n        '128': 'A128CBC',\n        '192': 'A192CBC',\n        '256': 'A256CBC'\n      }\n    }[a.name][(a.hash || {}).name || a.length || ''];\n  }\n  function b2jwk(k) {\n    if (k instanceof ArrayBuffer || k instanceof Uint8Array) k = JSON.parse(decodeURIComponent(escape(b2s(k))));\n    var jwk = {\n      'kty': k.kty,\n      'alg': k.alg,\n      'ext': k.ext || k.extractable\n    };\n    switch (jwk.kty) {\n      case 'oct':\n        jwk.k = k.k;\n      case 'RSA':\n        ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi', 'oth'].forEach(function (x) {\n          if (x in k) jwk[x] = k[x];\n        });\n        break;\n      default:\n        throw new TypeError(\"Unsupported key type\");\n    }\n    return jwk;\n  }\n  function jwk2b(k) {\n    var jwk = b2jwk(k);\n    if (isIE) jwk['extractable'] = jwk.ext, delete jwk.ext;\n    return s2b(unescape(encodeURIComponent(JSON.stringify(jwk)))).buffer;\n  }\n  function pkcs2jwk(k) {\n    var info = b2der(k),\n      prv = false;\n    if (info.length > 2) prv = true, info.shift(); // remove version from PKCS#8 PrivateKeyInfo structure\n    var jwk = {\n      'ext': true\n    };\n    switch (info[0][0]) {\n      case '1.2.840.113549.1.1.1':\n        var rsaComp = ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi'],\n          rsaKey = b2der(info[1]);\n        if (prv) rsaKey.shift(); // remove version from PKCS#1 RSAPrivateKey structure\n        for (var i = 0; i < rsaKey.length; i++) {\n          if (!rsaKey[i][0]) rsaKey[i] = rsaKey[i].subarray(1);\n          jwk[rsaComp[i]] = s2a(b2s(rsaKey[i]));\n        }\n        jwk['kty'] = 'RSA';\n        break;\n      default:\n        throw new TypeError(\"Unsupported key type\");\n    }\n    return jwk;\n  }\n  function jwk2pkcs(k) {\n    var key,\n      info = [['', null]],\n      prv = false;\n    switch (k.kty) {\n      case 'RSA':\n        var rsaComp = ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi'],\n          rsaKey = [];\n        for (var i = 0; i < rsaComp.length; i++) {\n          if (!(rsaComp[i] in k)) break;\n          var b = rsaKey[i] = s2b(a2s(k[rsaComp[i]]));\n          if (b[0] & 0x80) rsaKey[i] = new Uint8Array(b.length + 1), rsaKey[i].set(b, 1);\n        }\n        if (rsaKey.length > 2) prv = true, rsaKey.unshift(new Uint8Array([0])); // add version to PKCS#1 RSAPrivateKey structure\n        info[0][0] = '1.2.840.113549.1.1.1';\n        key = rsaKey;\n        break;\n      default:\n        throw new TypeError(\"Unsupported key type\");\n    }\n    info.push(new Uint8Array(der2b(key)).buffer);\n    if (!prv) info[1] = {\n      'tag': 0x03,\n      'value': info[1]\n    };else info.unshift(new Uint8Array([0])); // add version to PKCS#8 PrivateKeyInfo structure\n    return new Uint8Array(der2b(info)).buffer;\n  }\n  var oid2str = {\n      'KoZIhvcNAQEB': '1.2.840.113549.1.1.1'\n    },\n    str2oid = {\n      '1.2.840.113549.1.1.1': 'KoZIhvcNAQEB'\n    };\n  function b2der(buf, ctx) {\n    if (buf instanceof ArrayBuffer) buf = new Uint8Array(buf);\n    if (!ctx) ctx = {\n      pos: 0,\n      end: buf.length\n    };\n    if (ctx.end - ctx.pos < 2 || ctx.end > buf.length) throw new RangeError(\"Malformed DER\");\n    var tag = buf[ctx.pos++],\n      len = buf[ctx.pos++];\n    if (len >= 0x80) {\n      len &= 0x7f;\n      if (ctx.end - ctx.pos < len) throw new RangeError(\"Malformed DER\");\n      for (var xlen = 0; len--;) xlen <<= 8, xlen |= buf[ctx.pos++];\n      len = xlen;\n    }\n    if (ctx.end - ctx.pos < len) throw new RangeError(\"Malformed DER\");\n    var rv;\n    switch (tag) {\n      case 0x02:\n        // Universal Primitive INTEGER\n        rv = buf.subarray(ctx.pos, ctx.pos += len);\n        break;\n      case 0x03:\n        // Universal Primitive BIT STRING\n        if (buf[ctx.pos++]) throw new Error(\"Unsupported bit string\");\n        len--;\n      case 0x04:\n        // Universal Primitive OCTET STRING\n        rv = new Uint8Array(buf.subarray(ctx.pos, ctx.pos += len)).buffer;\n        break;\n      case 0x05:\n        // Universal Primitive NULL\n        rv = null;\n        break;\n      case 0x06:\n        // Universal Primitive OBJECT IDENTIFIER\n        var oid = btoa(b2s(buf.subarray(ctx.pos, ctx.pos += len)));\n        if (!(oid in oid2str)) throw new Error(\"Unsupported OBJECT ID \" + oid);\n        rv = oid2str[oid];\n        break;\n      case 0x30:\n        // Universal Constructed SEQUENCE\n        rv = [];\n        for (var end = ctx.pos + len; ctx.pos < end;) rv.push(b2der(buf, ctx));\n        break;\n      default:\n        throw new Error(\"Unsupported DER tag 0x\" + tag.toString(16));\n    }\n    return rv;\n  }\n  function der2b(val, buf) {\n    if (!buf) buf = [];\n    var tag = 0,\n      len = 0,\n      pos = buf.length + 2;\n    buf.push(0, 0); // placeholder\n\n    if (val instanceof Uint8Array) {\n      // Universal Primitive INTEGER\n      tag = 0x02, len = val.length;\n      for (var i = 0; i < len; i++) buf.push(val[i]);\n    } else if (val instanceof ArrayBuffer) {\n      // Universal Primitive OCTET STRING\n      tag = 0x04, len = val.byteLength, val = new Uint8Array(val);\n      for (var i = 0; i < len; i++) buf.push(val[i]);\n    } else if (val === null) {\n      // Universal Primitive NULL\n      tag = 0x05, len = 0;\n    } else if (typeof val === 'string' && val in str2oid) {\n      // Universal Primitive OBJECT IDENTIFIER\n      var oid = s2b(atob(str2oid[val]));\n      tag = 0x06, len = oid.length;\n      for (var i = 0; i < len; i++) buf.push(oid[i]);\n    } else if (val instanceof Array) {\n      // Universal Constructed SEQUENCE\n      for (var i = 0; i < val.length; i++) der2b(val[i], buf);\n      tag = 0x30, len = buf.length - pos;\n    } else if (typeof val === 'object' && val.tag === 0x03 && val.value instanceof ArrayBuffer) {\n      // Tag hint\n      val = new Uint8Array(val.value), tag = 0x03, len = val.byteLength;\n      buf.push(0);\n      for (var i = 0; i < len; i++) buf.push(val[i]);\n      len++;\n    } else {\n      throw new Error(\"Unsupported DER value \" + val);\n    }\n    if (len >= 0x80) {\n      var xlen = len,\n        len = 4;\n      buf.splice(pos, 0, xlen >> 24 & 0xff, xlen >> 16 & 0xff, xlen >> 8 & 0xff, xlen & 0xff);\n      while (len > 1 && !(xlen >> 24)) xlen <<= 8, len--;\n      if (len < 4) buf.splice(pos, 4 - len);\n      len |= 0x80;\n    }\n    buf.splice(pos - 2, 2, tag, len);\n    return buf;\n  }\n  function CryptoKey(key, alg, ext, use) {\n    Object.defineProperties(this, {\n      _key: {\n        value: key\n      },\n      type: {\n        value: key.type,\n        enumerable: true\n      },\n      extractable: {\n        value: ext === undefined ? key.extractable : ext,\n        enumerable: true\n      },\n      algorithm: {\n        value: alg === undefined ? key.algorithm : alg,\n        enumerable: true\n      },\n      usages: {\n        value: use === undefined ? key.usages : use,\n        enumerable: true\n      }\n    });\n  }\n  function isPubKeyUse(u) {\n    return u === 'verify' || u === 'encrypt' || u === 'wrapKey';\n  }\n  function isPrvKeyUse(u) {\n    return u === 'sign' || u === 'decrypt' || u === 'unwrapKey';\n  }\n  ['generateKey', 'importKey', 'unwrapKey'].forEach(function (m) {\n    var _fn = _subtle[m];\n    _subtle[m] = function (a, b, c) {\n      var args = [].slice.call(arguments),\n        ka,\n        kx,\n        ku;\n      switch (m) {\n        case 'generateKey':\n          ka = alg(a), kx = b, ku = c;\n          break;\n        case 'importKey':\n          ka = alg(c), kx = args[3], ku = args[4];\n          if (a === 'jwk') {\n            b = b2jwk(b);\n            if (!b.alg) b.alg = jwkAlg(ka);\n            if (!b.key_ops) b.key_ops = b.kty !== 'oct' ? 'd' in b ? ku.filter(isPrvKeyUse) : ku.filter(isPubKeyUse) : ku.slice();\n            args[1] = jwk2b(b);\n          }\n          break;\n        case 'unwrapKey':\n          ka = args[4], kx = args[5], ku = args[6];\n          args[2] = c._key;\n          break;\n      }\n      if (m === 'generateKey' && ka.name === 'HMAC' && ka.hash) {\n        ka.length = ka.length || {\n          'SHA-1': 512,\n          'SHA-256': 512,\n          'SHA-384': 1024,\n          'SHA-512': 1024\n        }[ka.hash.name];\n        return _subtle.importKey('raw', _crypto.getRandomValues(new Uint8Array(ka.length + 7 >> 3)), ka, kx, ku);\n      }\n      if (isWebkit && m === 'generateKey' && ka.name === 'RSASSA-PKCS1-v1_5' && (!ka.modulusLength || ka.modulusLength >= 2048)) {\n        a = alg(a), a.name = 'RSAES-PKCS1-v1_5', delete a.hash;\n        return _subtle.generateKey(a, true, ['encrypt', 'decrypt']).then(function (k) {\n          return Promise.all([_subtle.exportKey('jwk', k.publicKey), _subtle.exportKey('jwk', k.privateKey)]);\n        }).then(function (keys) {\n          keys[0].alg = keys[1].alg = jwkAlg(ka);\n          keys[0].key_ops = ku.filter(isPubKeyUse), keys[1].key_ops = ku.filter(isPrvKeyUse);\n          return Promise.all([_subtle.importKey('jwk', keys[0], ka, true, keys[0].key_ops), _subtle.importKey('jwk', keys[1], ka, kx, keys[1].key_ops)]);\n        }).then(function (keys) {\n          return {\n            publicKey: keys[0],\n            privateKey: keys[1]\n          };\n        });\n      }\n      if ((isWebkit || isIE && (ka.hash || {}).name === 'SHA-1') && m === 'importKey' && a === 'jwk' && ka.name === 'HMAC' && b.kty === 'oct') {\n        return _subtle.importKey('raw', s2b(a2s(b.k)), c, args[3], args[4]);\n      }\n      if (isWebkit && m === 'importKey' && (a === 'spki' || a === 'pkcs8')) {\n        return _subtle.importKey('jwk', pkcs2jwk(b), c, args[3], args[4]);\n      }\n      if (isIE && m === 'unwrapKey') {\n        return _subtle.decrypt(args[3], c, b).then(function (k) {\n          return _subtle.importKey(a, k, args[4], args[5], args[6]);\n        });\n      }\n      var op;\n      try {\n        op = _fn.apply(_subtle, args);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      if (isIE) {\n        op = new Promise(function (res, rej) {\n          op.onabort = op.onerror = function (e) {\n            rej(e);\n          };\n          op.oncomplete = function (r) {\n            res(r.target.result);\n          };\n        });\n      }\n      op = op.then(function (k) {\n        if (ka.name === 'HMAC') {\n          if (!ka.length) ka.length = 8 * k.algorithm.length;\n        }\n        if (ka.name.search('RSA') == 0) {\n          if (!ka.modulusLength) ka.modulusLength = (k.publicKey || k).algorithm.modulusLength;\n          if (!ka.publicExponent) ka.publicExponent = (k.publicKey || k).algorithm.publicExponent;\n        }\n        if (k.publicKey && k.privateKey) {\n          k = {\n            publicKey: new CryptoKey(k.publicKey, ka, kx, ku.filter(isPubKeyUse)),\n            privateKey: new CryptoKey(k.privateKey, ka, kx, ku.filter(isPrvKeyUse))\n          };\n        } else {\n          k = new CryptoKey(k, ka, kx, ku);\n        }\n        return k;\n      });\n      return op;\n    };\n  });\n  ['exportKey', 'wrapKey'].forEach(function (m) {\n    var _fn = _subtle[m];\n    _subtle[m] = function (a, b, c) {\n      var args = [].slice.call(arguments);\n      switch (m) {\n        case 'exportKey':\n          args[1] = b._key;\n          break;\n        case 'wrapKey':\n          args[1] = b._key, args[2] = c._key;\n          break;\n      }\n      if ((isWebkit || isIE && (b.algorithm.hash || {}).name === 'SHA-1') && m === 'exportKey' && a === 'jwk' && b.algorithm.name === 'HMAC') {\n        args[0] = 'raw';\n      }\n      if (isWebkit && m === 'exportKey' && (a === 'spki' || a === 'pkcs8')) {\n        args[0] = 'jwk';\n      }\n      if (isIE && m === 'wrapKey') {\n        return _subtle.exportKey(a, b).then(function (k) {\n          if (a === 'jwk') k = s2b(unescape(encodeURIComponent(JSON.stringify(b2jwk(k)))));\n          return _subtle.encrypt(args[3], c, k);\n        });\n      }\n      var op;\n      try {\n        op = _fn.apply(_subtle, args);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      if (isIE) {\n        op = new Promise(function (res, rej) {\n          op.onabort = op.onerror = function (e) {\n            rej(e);\n          };\n          op.oncomplete = function (r) {\n            res(r.target.result);\n          };\n        });\n      }\n      if (m === 'exportKey' && a === 'jwk') {\n        op = op.then(function (k) {\n          if ((isWebkit || isIE && (b.algorithm.hash || {}).name === 'SHA-1') && b.algorithm.name === 'HMAC') {\n            return {\n              'kty': 'oct',\n              'alg': jwkAlg(b.algorithm),\n              'key_ops': b.usages.slice(),\n              'ext': true,\n              'k': s2a(b2s(k))\n            };\n          }\n          k = b2jwk(k);\n          if (!k.alg) k['alg'] = jwkAlg(b.algorithm);\n          if (!k.key_ops) k['key_ops'] = b.type === 'public' ? b.usages.filter(isPubKeyUse) : b.type === 'private' ? b.usages.filter(isPrvKeyUse) : b.usages.slice();\n          return k;\n        });\n      }\n      if (isWebkit && m === 'exportKey' && (a === 'spki' || a === 'pkcs8')) {\n        op = op.then(function (k) {\n          k = jwk2pkcs(b2jwk(k));\n          return k;\n        });\n      }\n      return op;\n    };\n  });\n  ['encrypt', 'decrypt', 'sign', 'verify'].forEach(function (m) {\n    var _fn = _subtle[m];\n    _subtle[m] = function (a, b, c, d) {\n      if (isIE && (!c.byteLength || d && !d.byteLength)) throw new Error(\"Empy input is not allowed\");\n      var args = [].slice.call(arguments),\n        ka = alg(a);\n      if (isIE && m === 'decrypt' && ka.name === 'AES-GCM') {\n        var tl = a.tagLength >> 3;\n        args[2] = (c.buffer || c).slice(0, c.byteLength - tl), a.tag = (c.buffer || c).slice(c.byteLength - tl);\n      }\n      args[1] = b._key;\n      var op;\n      try {\n        op = _fn.apply(_subtle, args);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      if (isIE) {\n        op = new Promise(function (res, rej) {\n          op.onabort = op.onerror = function (e) {\n            rej(e);\n          };\n          op.oncomplete = function (r) {\n            var r = r.target.result;\n            if (m === 'encrypt' && r instanceof AesGcmEncryptResult) {\n              var c = r.ciphertext,\n                t = r.tag;\n              r = new Uint8Array(c.byteLength + t.byteLength);\n              r.set(new Uint8Array(c), 0);\n              r.set(new Uint8Array(t), c.byteLength);\n              r = r.buffer;\n            }\n            res(r);\n          };\n        });\n      }\n      return op;\n    };\n  });\n  if (isIE) {\n    var _digest = _subtle.digest;\n    _subtle['digest'] = function (a, b) {\n      if (!b.byteLength) throw new Error(\"Empy input is not allowed\");\n      var op;\n      try {\n        op = _digest.call(_subtle, a, b);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      op = new Promise(function (res, rej) {\n        op.onabort = op.onerror = function (e) {\n          rej(e);\n        };\n        op.oncomplete = function (r) {\n          res(r.target.result);\n        };\n      });\n      return op;\n    };\n    global.crypto = Object.create(_crypto, {\n      getRandomValues: {\n        value: function (a) {\n          return _crypto.getRandomValues(a);\n        }\n      },\n      subtle: {\n        value: _subtle\n      }\n    });\n    global.CryptoKey = CryptoKey;\n  }\n  if (isWebkit) {\n    _crypto.subtle = _subtle;\n    global.Crypto = _Crypto;\n    global.SubtleCrypto = _SubtleCrypto;\n    global.CryptoKey = CryptoKey;\n  }\n});\nexport default {}; // section modified by isomorphic-webcrypto build","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}