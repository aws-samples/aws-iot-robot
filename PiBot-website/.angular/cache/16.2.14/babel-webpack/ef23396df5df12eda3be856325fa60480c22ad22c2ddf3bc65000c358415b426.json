{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigV4RequestSigner = void 0;\nvar tslib_1 = require(\"tslib\");\nvar isomorphic_webcrypto_1 = tslib_1.__importDefault(require(\"isomorphic-webcrypto\"));\nvar utils_1 = require(\"./internal/utils\");\n/**\n * Utility class for SigV4 signing requests. The AWS SDK cannot be used for this purpose because it does not have support for WebSocket endpoints.\n */\nvar SigV4RequestSigner = /** @class */function () {\n  function SigV4RequestSigner(region, credentials, service) {\n    if (service === void 0) {\n      service = SigV4RequestSigner.DEFAULT_SERVICE;\n    }\n    this.region = region;\n    this.credentials = credentials;\n    this.service = service;\n  }\n  /**\n   * Creates a SigV4 signed WebSocket URL for the given host/endpoint with the given query params.\n   *\n   * @param endpoint The WebSocket service endpoint including protocol, hostname, and path (if applicable).\n   * @param queryParams Query parameters to include in the URL.\n   * @param date Date to use for request signing. Defaults to NOW.\n   *\n   * Implementation note: Query parameters should be in alphabetical order.\n   *\n   * Note from AWS docs: \"When you add the X-Amz-Security-Token parameter to the query string, some services require that you include this parameter in the\n   * canonical (signed) request. For other services, you add this parameter at the end, after you calculate the signature. For details, see the API reference\n   * documentation for that service.\" KVS Signaling Service requires that the session token is added to the canonical request.\n   *\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n   * @see https://gist.github.com/prestomation/24b959e51250a8723b9a5a4f70dcae08\n   */\n  SigV4RequestSigner.prototype.getSignedURL = function (endpoint, queryParams, date) {\n    if (date === void 0) {\n      date = new Date();\n    }\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var datetimeString, dateString, protocol, urlProtocol, pathStartIndex, host, path, signedHeaders, method, credentialScope, canonicalQueryParams, canonicalQueryString, canonicalHeaders, canonicalHeadersString, payloadHash, canonicalRequest, canonicalRequestHash, stringToSign, signingKey, signature, _a, _b, signedQueryParams;\n      return tslib_1.__generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(typeof this.credentials.getPromise === 'function')) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.credentials.getPromise()];\n          case 1:\n            _c.sent();\n            _c.label = 2;\n          case 2:\n            (0, utils_1.validateValueNonNil)(this.credentials.accessKeyId, 'credentials.accessKeyId');\n            (0, utils_1.validateValueNonNil)(this.credentials.secretAccessKey, 'credentials.secretAccessKey');\n            datetimeString = SigV4RequestSigner.getDateTimeString(date);\n            dateString = SigV4RequestSigner.getDateString(date);\n            protocol = 'wss';\n            urlProtocol = \"\".concat(protocol, \"://\");\n            if (!endpoint.startsWith(urlProtocol)) {\n              throw new Error(\"Endpoint '\".concat(endpoint, \"' is not a secure WebSocket endpoint. It should start with '\").concat(urlProtocol, \"'.\"));\n            }\n            if (endpoint.includes('?')) {\n              throw new Error(\"Endpoint '\".concat(endpoint, \"' should not contain any query parameters.\"));\n            }\n            pathStartIndex = endpoint.indexOf('/', urlProtocol.length);\n            if (pathStartIndex < 0) {\n              host = endpoint.substring(urlProtocol.length);\n              path = '/';\n            } else {\n              host = endpoint.substring(urlProtocol.length, pathStartIndex);\n              path = endpoint.substring(pathStartIndex);\n            }\n            signedHeaders = ['host'].join(';');\n            method = 'GET';\n            credentialScope = dateString + '/' + this.region + '/' + this.service + '/' + 'aws4_request';\n            canonicalQueryParams = Object.assign({}, queryParams, {\n              'X-Amz-Algorithm': SigV4RequestSigner.DEFAULT_ALGORITHM,\n              'X-Amz-Credential': this.credentials.accessKeyId + '/' + credentialScope,\n              'X-Amz-Date': datetimeString,\n              'X-Amz-Expires': '299',\n              'X-Amz-SignedHeaders': signedHeaders\n            });\n            if (this.credentials.sessionToken) {\n              Object.assign(canonicalQueryParams, {\n                'X-Amz-Security-Token': this.credentials.sessionToken\n              });\n            }\n            canonicalQueryString = SigV4RequestSigner.createQueryString(canonicalQueryParams);\n            canonicalHeaders = {\n              host: host\n            };\n            canonicalHeadersString = SigV4RequestSigner.createHeadersString(canonicalHeaders);\n            return [4 /*yield*/, SigV4RequestSigner.sha256('')];\n          case 3:\n            payloadHash = _c.sent();\n            canonicalRequest = [method, path, canonicalQueryString, canonicalHeadersString, signedHeaders, payloadHash].join('\\n');\n            return [4 /*yield*/, SigV4RequestSigner.sha256(canonicalRequest)];\n          case 4:\n            canonicalRequestHash = _c.sent();\n            stringToSign = [SigV4RequestSigner.DEFAULT_ALGORITHM, datetimeString, credentialScope, canonicalRequestHash].join('\\n');\n            return [4 /*yield*/, this.getSignatureKey(dateString)];\n          case 5:\n            signingKey = _c.sent();\n            _b = (_a = SigV4RequestSigner).toHex;\n            return [4 /*yield*/, SigV4RequestSigner.hmac(signingKey, stringToSign)];\n          case 6:\n            return [4 /*yield*/, _b.apply(_a, [_c.sent()])];\n          case 7:\n            signature = _c.sent();\n            signedQueryParams = Object.assign({}, canonicalQueryParams, {\n              'X-Amz-Signature': signature\n            });\n            // Create signed URL\n            return [2 /*return*/, protocol + '://' + host + path + '?' + SigV4RequestSigner.createQueryString(signedQueryParams)];\n        }\n      });\n    });\n  };\n  /**\n   * Utility method for generating the key to use for calculating the signature. This combines together the date string, region, service name, and secret\n   * access key.\n   *\n   * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n   */\n  SigV4RequestSigner.prototype.getSignatureKey = function (dateString) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var kDate, kRegion, kService;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, SigV4RequestSigner.hmac('AWS4' + this.credentials.secretAccessKey, dateString)];\n          case 1:\n            kDate = _a.sent();\n            return [4 /*yield*/, SigV4RequestSigner.hmac(kDate, this.region)];\n          case 2:\n            kRegion = _a.sent();\n            return [4 /*yield*/, SigV4RequestSigner.hmac(kRegion, this.service)];\n          case 3:\n            kService = _a.sent();\n            return [4 /*yield*/, SigV4RequestSigner.hmac(kService, 'aws4_request')];\n          case 4:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Utility method for converting a map of headers to a string for signing.\n   */\n  SigV4RequestSigner.createHeadersString = function (headers) {\n    return Object.keys(headers).map(function (header) {\n      return \"\".concat(header, \":\").concat(headers[header], \"\\n\");\n    }).join();\n  };\n  /**\n   * Utility method for converting a map of query parameters to a string with the parameter names sorted.\n   */\n  SigV4RequestSigner.createQueryString = function (queryParams) {\n    return Object.keys(queryParams).sort().map(function (key) {\n      return \"\".concat(key, \"=\").concat(encodeURIComponent(queryParams[key]));\n    }).join('&');\n  };\n  /**\n   * Gets a datetime string for the given date to use for signing. For example: \"20190927T165210Z\"\n   * @param date\n   */\n  SigV4RequestSigner.getDateTimeString = function (date) {\n    return date.toISOString().replace(/\\.\\d{3}Z$/, 'Z').replace(/[:\\-]/g, '');\n  };\n  /**\n   * Gets a date string for the given date to use for signing. For example: \"20190927\"\n   * @param date\n   */\n  SigV4RequestSigner.getDateString = function (date) {\n    return this.getDateTimeString(date).substring(0, 8);\n  };\n  SigV4RequestSigner.sha256 = function (message) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var hashBuffer;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, isomorphic_webcrypto_1.default.subtle.digest({\n              name: 'SHA-256'\n            }, this.toUint8Array(message))];\n          case 1:\n            hashBuffer = _a.sent();\n            return [2 /*return*/, this.toHex(hashBuffer)];\n        }\n      });\n    });\n  };\n  SigV4RequestSigner.hmac = function (key, message) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var keyBuffer, messageBuffer, cryptoKey;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            keyBuffer = typeof key === 'string' ? this.toUint8Array(key).buffer : key;\n            messageBuffer = this.toUint8Array(message).buffer;\n            return [4 /*yield*/, isomorphic_webcrypto_1.default.subtle.importKey('raw', keyBuffer, {\n              name: 'HMAC',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, false, ['sign'])];\n          case 1:\n            cryptoKey = _a.sent();\n            return [4 /*yield*/, isomorphic_webcrypto_1.default.subtle.sign({\n              name: 'HMAC',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, cryptoKey, messageBuffer)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Note that this implementation does not work with two-byte characters.\n   * However, no inputs into a signed signaling service request should have two-byte characters.\n   */\n  SigV4RequestSigner.toUint8Array = function (input) {\n    var buf = new ArrayBuffer(input.length);\n    var bufView = new Uint8Array(buf);\n    for (var i = 0, strLen = input.length; i < strLen; i++) {\n      bufView[i] = input.charCodeAt(i);\n    }\n    return bufView;\n  };\n  SigV4RequestSigner.toHex = function (buffer) {\n    return Array.from(new Uint8Array(buffer)).map(function (b) {\n      return b.toString(16).padStart(2, '0');\n    }).join('');\n  };\n  SigV4RequestSigner.DEFAULT_ALGORITHM = 'AWS4-HMAC-SHA256';\n  SigV4RequestSigner.DEFAULT_SERVICE = 'kinesisvideo';\n  return SigV4RequestSigner;\n}();\nexports.SigV4RequestSigner = SigV4RequestSigner;\n//# sourceMappingURL=SigV4RequestSigner.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}