{"ast":null,"code":"(function (exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n      return true;\n    } else if (isArray(obj) && obj.length === 0) {\n      // Check for an empty array.\n      return true;\n    } else if (isObject(obj)) {\n      // Check for an empty object.\n      for (var key in obj) {\n        // If there are any keys, then\n        // the object is not empty so the object\n        // is not false.\n        if (obj.hasOwnProperty(key)) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n  function merge(a, b) {\n    var merged = {};\n    for (var key in a) {\n      merged[key] = a[key];\n    }\n    for (var key2 in b) {\n      merged[key2] = b[key2];\n    }\n    return merged;\n  }\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function (str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function (str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  // Type constants used to define functions.\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>'\n  };\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN = \"Lparen\";\n  var TOK_LITERAL = \"Literal\";\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n  var operatorStartToken = {\n    \"<\": true,\n    \">\": true,\n    \"=\": true,\n    \"!\": true\n  };\n  var skipChars = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\n\": true\n  };\n  function isAlpha(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch === \"_\";\n  }\n  function isNum(ch) {\n    return ch >= \"0\" && ch <= \"9\" || ch === \"-\";\n  }\n  function isAlphaNum(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch >= \"0\" && ch <= \"9\" || ch === \"_\";\n  }\n  function Lexer() {}\n  Lexer.prototype = {\n    tokenize: function (stream) {\n      var tokens = [];\n      this._current = 0;\n      var start;\n      var identifier;\n      var token;\n      while (this._current < stream.length) {\n        if (isAlpha(stream[this._current])) {\n          start = this._current;\n          identifier = this._consumeUnquotedIdentifier(stream);\n          tokens.push({\n            type: TOK_UNQUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (basicTokens[stream[this._current]] !== undefined) {\n          tokens.push({\n            type: basicTokens[stream[this._current]],\n            value: stream[this._current],\n            start: this._current\n          });\n          this._current++;\n        } else if (isNum(stream[this._current])) {\n          token = this._consumeNumber(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"[\") {\n          // No need to increment this._current.  This happens\n          // in _consumeLBracket\n          token = this._consumeLBracket(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"\\\"\") {\n          start = this._current;\n          identifier = this._consumeQuotedIdentifier(stream);\n          tokens.push({\n            type: TOK_QUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"'\") {\n          start = this._current;\n          identifier = this._consumeRawStringLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"`\") {\n          start = this._current;\n          var literal = this._consumeLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: literal,\n            start: start\n          });\n        } else if (operatorStartToken[stream[this._current]] !== undefined) {\n          tokens.push(this._consumeOperator(stream));\n        } else if (skipChars[stream[this._current]] !== undefined) {\n          // Ignore whitespace.\n          this._current++;\n        } else if (stream[this._current] === \"&\") {\n          start = this._current;\n          this._current++;\n          if (stream[this._current] === \"&\") {\n            this._current++;\n            tokens.push({\n              type: TOK_AND,\n              value: \"&&\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_EXPREF,\n              value: \"&\",\n              start: start\n            });\n          }\n        } else if (stream[this._current] === \"|\") {\n          start = this._current;\n          this._current++;\n          if (stream[this._current] === \"|\") {\n            this._current++;\n            tokens.push({\n              type: TOK_OR,\n              value: \"||\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_PIPE,\n              value: \"|\",\n              start: start\n            });\n          }\n        } else {\n          var error = new Error(\"Unknown character:\" + stream[this._current]);\n          error.name = \"LexerError\";\n          throw error;\n        }\n      }\n      return tokens;\n    },\n    _consumeUnquotedIdentifier: function (stream) {\n      var start = this._current;\n      this._current++;\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n        this._current++;\n      }\n      return stream.slice(start, this._current);\n    },\n    _consumeQuotedIdentifier: function (stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n      while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n        // You can escape a double quote and you can escape an escape.\n        var current = this._current;\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"\\\"\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n        this._current = current;\n      }\n      this._current++;\n      return JSON.parse(stream.slice(start, this._current));\n    },\n    _consumeRawStringLiteral: function (stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n      while (stream[this._current] !== \"'\" && this._current < maxLength) {\n        // You can escape a single quote and you can escape an escape.\n        var current = this._current;\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"'\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n        this._current = current;\n      }\n      this._current++;\n      var literal = stream.slice(start + 1, this._current - 1);\n      return literal.replace(\"\\\\'\", \"'\");\n    },\n    _consumeNumber: function (stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n      while (isNum(stream[this._current]) && this._current < maxLength) {\n        this._current++;\n      }\n      var value = parseInt(stream.slice(start, this._current));\n      return {\n        type: TOK_NUMBER,\n        value: value,\n        start: start\n      };\n    },\n    _consumeLBracket: function (stream) {\n      var start = this._current;\n      this._current++;\n      if (stream[this._current] === \"?\") {\n        this._current++;\n        return {\n          type: TOK_FILTER,\n          value: \"[?\",\n          start: start\n        };\n      } else if (stream[this._current] === \"]\") {\n        this._current++;\n        return {\n          type: TOK_FLATTEN,\n          value: \"[]\",\n          start: start\n        };\n      } else {\n        return {\n          type: TOK_LBRACKET,\n          value: \"[\",\n          start: start\n        };\n      }\n    },\n    _consumeOperator: function (stream) {\n      var start = this._current;\n      var startingChar = stream[start];\n      this._current++;\n      if (startingChar === \"!\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_NE,\n            value: \"!=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_NOT,\n            value: \"!\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"<\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_LTE,\n            value: \"<=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_LT,\n            value: \"<\",\n            start: start\n          };\n        }\n      } else if (startingChar === \">\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_GTE,\n            value: \">=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_GT,\n            value: \">\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"=\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_EQ,\n            value: \"==\",\n            start: start\n          };\n        }\n      }\n    },\n    _consumeLiteral: function (stream) {\n      this._current++;\n      var start = this._current;\n      var maxLength = stream.length;\n      var literal;\n      while (stream[this._current] !== \"`\" && this._current < maxLength) {\n        // You can escape a literal char or you can escape the escape.\n        var current = this._current;\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"`\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n        this._current = current;\n      }\n      var literalString = trimLeft(stream.slice(start, this._current));\n      literalString = literalString.replace(\"\\\\`\", \"`\");\n      if (this._looksLikeJSON(literalString)) {\n        literal = JSON.parse(literalString);\n      } else {\n        // Try to JSON parse it as \"<literal>\"\n        literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n      }\n      // +1 gets us to the ending \"`\", +1 to move on to the next char.\n      this._current++;\n      return literal;\n    },\n    _looksLikeJSON: function (literalString) {\n      var startingChars = \"[{\\\"\";\n      var jsonLiterals = [\"true\", \"false\", \"null\"];\n      var numberLooking = \"-0123456789\";\n      if (literalString === \"\") {\n        return false;\n      } else if (startingChars.indexOf(literalString[0]) >= 0) {\n        return true;\n      } else if (jsonLiterals.indexOf(literalString) >= 0) {\n        return true;\n      } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n        try {\n          JSON.parse(literalString);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  };\n  var bindingPower = {};\n  bindingPower[TOK_EOF] = 0;\n  bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_RBRACKET] = 0;\n  bindingPower[TOK_RPAREN] = 0;\n  bindingPower[TOK_COMMA] = 0;\n  bindingPower[TOK_RBRACE] = 0;\n  bindingPower[TOK_NUMBER] = 0;\n  bindingPower[TOK_CURRENT] = 0;\n  bindingPower[TOK_EXPREF] = 0;\n  bindingPower[TOK_PIPE] = 1;\n  bindingPower[TOK_OR] = 2;\n  bindingPower[TOK_AND] = 3;\n  bindingPower[TOK_EQ] = 5;\n  bindingPower[TOK_GT] = 5;\n  bindingPower[TOK_LT] = 5;\n  bindingPower[TOK_GTE] = 5;\n  bindingPower[TOK_LTE] = 5;\n  bindingPower[TOK_NE] = 5;\n  bindingPower[TOK_FLATTEN] = 9;\n  bindingPower[TOK_STAR] = 20;\n  bindingPower[TOK_FILTER] = 21;\n  bindingPower[TOK_DOT] = 40;\n  bindingPower[TOK_NOT] = 45;\n  bindingPower[TOK_LBRACE] = 50;\n  bindingPower[TOK_LBRACKET] = 55;\n  bindingPower[TOK_LPAREN] = 60;\n  function Parser() {}\n  Parser.prototype = {\n    parse: function (expression) {\n      this._loadTokens(expression);\n      this.index = 0;\n      var ast = this.expression(0);\n      if (this._lookahead(0) !== TOK_EOF) {\n        var t = this._lookaheadToken(0);\n        var error = new Error(\"Unexpected token type: \" + t.type + \", value: \" + t.value);\n        error.name = \"ParserError\";\n        throw error;\n      }\n      return ast;\n    },\n    _loadTokens: function (expression) {\n      var lexer = new Lexer();\n      var tokens = lexer.tokenize(expression);\n      tokens.push({\n        type: TOK_EOF,\n        value: \"\",\n        start: expression.length\n      });\n      this.tokens = tokens;\n    },\n    expression: function (rbp) {\n      var leftToken = this._lookaheadToken(0);\n      this._advance();\n      var left = this.nud(leftToken);\n      var currentToken = this._lookahead(0);\n      while (rbp < bindingPower[currentToken]) {\n        this._advance();\n        left = this.led(currentToken, left);\n        currentToken = this._lookahead(0);\n      }\n      return left;\n    },\n    _lookahead: function (number) {\n      return this.tokens[this.index + number].type;\n    },\n    _lookaheadToken: function (number) {\n      return this.tokens[this.index + number];\n    },\n    _advance: function () {\n      this.index++;\n    },\n    nud: function (token) {\n      var left;\n      var right;\n      var expression;\n      switch (token.type) {\n        case TOK_LITERAL:\n          return {\n            type: \"Literal\",\n            value: token.value\n          };\n        case TOK_UNQUOTEDIDENTIFIER:\n          return {\n            type: \"Field\",\n            name: token.value\n          };\n        case TOK_QUOTEDIDENTIFIER:\n          var node = {\n            type: \"Field\",\n            name: token.value\n          };\n          if (this._lookahead(0) === TOK_LPAREN) {\n            throw new Error(\"Quoted identifier not allowed for function names.\");\n          }\n          return node;\n        case TOK_NOT:\n          right = this.expression(bindingPower.Not);\n          return {\n            type: \"NotExpression\",\n            children: [right]\n          };\n        case TOK_STAR:\n          left = {\n            type: \"Identity\"\n          };\n          right = null;\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            // This can happen in a multiselect,\n            // [a, b, *]\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Star);\n          }\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n        case TOK_FILTER:\n          return this.led(token.type, {\n            type: \"Identity\"\n          });\n        case TOK_LBRACE:\n          return this._parseMultiselectHash();\n        case TOK_FLATTEN:\n          left = {\n            type: TOK_FLATTEN,\n            children: [{\n              type: \"Identity\"\n            }]\n          };\n          right = this._parseProjectionRHS(bindingPower.Flatten);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n        case TOK_LBRACKET:\n          if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice({\n              type: \"Identity\"\n            }, right);\n          } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n            this._advance();\n            this._advance();\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: \"Projection\",\n              children: [{\n                type: \"Identity\"\n              }, right]\n            };\n          }\n          return this._parseMultiselectList();\n        case TOK_CURRENT:\n          return {\n            type: TOK_CURRENT\n          };\n        case TOK_EXPREF:\n          expression = this.expression(bindingPower.Expref);\n          return {\n            type: \"ExpressionReference\",\n            children: [expression]\n          };\n        case TOK_LPAREN:\n          var args = [];\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          return args[0];\n        default:\n          this._errorToken(token);\n      }\n    },\n    led: function (tokenName, left) {\n      var right;\n      switch (tokenName) {\n        case TOK_DOT:\n          var rbp = bindingPower.Dot;\n          if (this._lookahead(0) !== TOK_STAR) {\n            right = this._parseDotRHS(rbp);\n            return {\n              type: \"Subexpression\",\n              children: [left, right]\n            };\n          }\n          // Creating a projection.\n          this._advance();\n          right = this._parseProjectionRHS(rbp);\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n        case TOK_PIPE:\n          right = this.expression(bindingPower.Pipe);\n          return {\n            type: TOK_PIPE,\n            children: [left, right]\n          };\n        case TOK_OR:\n          right = this.expression(bindingPower.Or);\n          return {\n            type: \"OrExpression\",\n            children: [left, right]\n          };\n        case TOK_AND:\n          right = this.expression(bindingPower.And);\n          return {\n            type: \"AndExpression\",\n            children: [left, right]\n          };\n        case TOK_LPAREN:\n          var name = left.name;\n          var args = [];\n          var expression, node;\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          node = {\n            type: \"Function\",\n            name: name,\n            children: args\n          };\n          return node;\n        case TOK_FILTER:\n          var condition = this.expression(0);\n          this._match(TOK_RBRACKET);\n          if (this._lookahead(0) === TOK_FLATTEN) {\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Filter);\n          }\n          return {\n            type: \"FilterProjection\",\n            children: [left, right, condition]\n          };\n        case TOK_FLATTEN:\n          var leftNode = {\n            type: TOK_FLATTEN,\n            children: [left]\n          };\n          var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n          return {\n            type: \"Projection\",\n            children: [leftNode, rightNode]\n          };\n        case TOK_EQ:\n        case TOK_NE:\n        case TOK_GT:\n        case TOK_GTE:\n        case TOK_LT:\n        case TOK_LTE:\n          return this._parseComparator(left, tokenName);\n        case TOK_LBRACKET:\n          var token = this._lookaheadToken(0);\n          if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice(left, right);\n          }\n          this._match(TOK_STAR);\n          this._match(TOK_RBRACKET);\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n        default:\n          this._errorToken(this._lookaheadToken(0));\n      }\n    },\n    _match: function (tokenType) {\n      if (this._lookahead(0) === tokenType) {\n        this._advance();\n      } else {\n        var t = this._lookaheadToken(0);\n        var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n        error.name = \"ParserError\";\n        throw error;\n      }\n    },\n    _errorToken: function (token) {\n      var error = new Error(\"Invalid token (\" + token.type + \"): \\\"\" + token.value + \"\\\"\");\n      error.name = \"ParserError\";\n      throw error;\n    },\n    _parseIndexExpression: function () {\n      if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n        return this._parseSliceExpression();\n      } else {\n        var node = {\n          type: \"Index\",\n          value: this._lookaheadToken(0).value\n        };\n        this._advance();\n        this._match(TOK_RBRACKET);\n        return node;\n      }\n    },\n    _projectIfSlice: function (left, right) {\n      var indexExpr = {\n        type: \"IndexExpression\",\n        children: [left, right]\n      };\n      if (right.type === \"Slice\") {\n        return {\n          type: \"Projection\",\n          children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n        };\n      } else {\n        return indexExpr;\n      }\n    },\n    _parseSliceExpression: function () {\n      // [start:end:step] where each part is optional, as well as the last\n      // colon.\n      var parts = [null, null, null];\n      var index = 0;\n      var currentToken = this._lookahead(0);\n      while (currentToken !== TOK_RBRACKET && index < 3) {\n        if (currentToken === TOK_COLON) {\n          index++;\n          this._advance();\n        } else if (currentToken === TOK_NUMBER) {\n          parts[index] = this._lookaheadToken(0).value;\n          this._advance();\n        } else {\n          var t = this._lookahead(0);\n          var error = new Error(\"Syntax error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n          error.name = \"Parsererror\";\n          throw error;\n        }\n        currentToken = this._lookahead(0);\n      }\n      this._match(TOK_RBRACKET);\n      return {\n        type: \"Slice\",\n        children: parts\n      };\n    },\n    _parseComparator: function (left, comparator) {\n      var right = this.expression(bindingPower[comparator]);\n      return {\n        type: \"Comparator\",\n        name: comparator,\n        children: [left, right]\n      };\n    },\n    _parseDotRHS: function (rbp) {\n      var lookahead = this._lookahead(0);\n      var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n      if (exprTokens.indexOf(lookahead) >= 0) {\n        return this.expression(rbp);\n      } else if (lookahead === TOK_LBRACKET) {\n        this._match(TOK_LBRACKET);\n        return this._parseMultiselectList();\n      } else if (lookahead === TOK_LBRACE) {\n        this._match(TOK_LBRACE);\n        return this._parseMultiselectHash();\n      }\n    },\n    _parseProjectionRHS: function (rbp) {\n      var right;\n      if (bindingPower[this._lookahead(0)] < 10) {\n        right = {\n          type: \"Identity\"\n        };\n      } else if (this._lookahead(0) === TOK_LBRACKET) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_FILTER) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_DOT) {\n        this._match(TOK_DOT);\n        right = this._parseDotRHS(rbp);\n      } else {\n        var t = this._lookaheadToken(0);\n        var error = new Error(\"Sytanx error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n        error.name = \"ParserError\";\n        throw error;\n      }\n      return right;\n    },\n    _parseMultiselectList: function () {\n      var expressions = [];\n      while (this._lookahead(0) !== TOK_RBRACKET) {\n        var expression = this.expression(0);\n        expressions.push(expression);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            throw new Error(\"Unexpected token Rbracket\");\n          }\n        }\n      }\n      this._match(TOK_RBRACKET);\n      return {\n        type: \"MultiSelectList\",\n        children: expressions\n      };\n    },\n    _parseMultiselectHash: function () {\n      var pairs = [];\n      var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n      var keyToken, keyName, value, node;\n      for (;;) {\n        keyToken = this._lookaheadToken(0);\n        if (identifierTypes.indexOf(keyToken.type) < 0) {\n          throw new Error(\"Expecting an identifier token, got: \" + keyToken.type);\n        }\n        keyName = keyToken.value;\n        this._advance();\n        this._match(TOK_COLON);\n        value = this.expression(0);\n        node = {\n          type: \"KeyValuePair\",\n          name: keyName,\n          value: value\n        };\n        pairs.push(node);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n        } else if (this._lookahead(0) === TOK_RBRACE) {\n          this._match(TOK_RBRACE);\n          break;\n        }\n      }\n      return {\n        type: \"MultiSelectHash\",\n        children: pairs\n      };\n    }\n  };\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n  TreeInterpreter.prototype = {\n    search: function (node, value) {\n      return this.visit(node, value);\n    },\n    visit: function (node, value) {\n      var matched, current, result, first, second, field, left, right, collected, i;\n      switch (node.type) {\n        case \"Field\":\n          if (value !== null && isObject(value)) {\n            field = value[node.name];\n            if (field === undefined) {\n              return null;\n            } else {\n              return field;\n            }\n          }\n          return null;\n        case \"Subexpression\":\n          result = this.visit(node.children[0], value);\n          for (i = 1; i < node.children.length; i++) {\n            result = this.visit(node.children[1], result);\n            if (result === null) {\n              return null;\n            }\n          }\n          return result;\n        case \"IndexExpression\":\n          left = this.visit(node.children[0], value);\n          right = this.visit(node.children[1], left);\n          return right;\n        case \"Index\":\n          if (!isArray(value)) {\n            return null;\n          }\n          var index = node.value;\n          if (index < 0) {\n            index = value.length + index;\n          }\n          result = value[index];\n          if (result === undefined) {\n            result = null;\n          }\n          return result;\n        case \"Slice\":\n          if (!isArray(value)) {\n            return null;\n          }\n          var sliceParams = node.children.slice(0);\n          var computed = this.computeSliceParams(value.length, sliceParams);\n          var start = computed[0];\n          var stop = computed[1];\n          var step = computed[2];\n          result = [];\n          if (step > 0) {\n            for (i = start; i < stop; i += step) {\n              result.push(value[i]);\n            }\n          } else {\n            for (i = start; i > stop; i += step) {\n              result.push(value[i]);\n            }\n          }\n          return result;\n        case \"Projection\":\n          // Evaluate left child.\n          var base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < base.length; i++) {\n            current = this.visit(node.children[1], base[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case \"ValueProjection\":\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n          if (!isObject(base)) {\n            return null;\n          }\n          collected = [];\n          var values = objValues(base);\n          for (i = 0; i < values.length; i++) {\n            current = this.visit(node.children[1], values[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case \"FilterProjection\":\n          base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          var filtered = [];\n          var finalResults = [];\n          for (i = 0; i < base.length; i++) {\n            matched = this.visit(node.children[2], base[i]);\n            if (!isFalse(matched)) {\n              filtered.push(base[i]);\n            }\n          }\n          for (var j = 0; j < filtered.length; j++) {\n            current = this.visit(node.children[1], filtered[j]);\n            if (current !== null) {\n              finalResults.push(current);\n            }\n          }\n          return finalResults;\n        case \"Comparator\":\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          switch (node.name) {\n            case TOK_EQ:\n              result = strictDeepEqual(first, second);\n              break;\n            case TOK_NE:\n              result = !strictDeepEqual(first, second);\n              break;\n            case TOK_GT:\n              result = first > second;\n              break;\n            case TOK_GTE:\n              result = first >= second;\n              break;\n            case TOK_LT:\n              result = first < second;\n              break;\n            case TOK_LTE:\n              result = first <= second;\n              break;\n            default:\n              throw new Error(\"Unknown comparator: \" + node.name);\n          }\n          return result;\n        case TOK_FLATTEN:\n          var original = this.visit(node.children[0], value);\n          if (!isArray(original)) {\n            return null;\n          }\n          var merged = [];\n          for (i = 0; i < original.length; i++) {\n            current = original[i];\n            if (isArray(current)) {\n              merged.push.apply(merged, current);\n            } else {\n              merged.push(current);\n            }\n          }\n          return merged;\n        case \"Identity\":\n          return value;\n        case \"MultiSelectList\":\n          if (value === null) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < node.children.length; i++) {\n            collected.push(this.visit(node.children[i], value));\n          }\n          return collected;\n        case \"MultiSelectHash\":\n          if (value === null) {\n            return null;\n          }\n          collected = {};\n          var child;\n          for (i = 0; i < node.children.length; i++) {\n            child = node.children[i];\n            collected[child.name] = this.visit(child.value, value);\n          }\n          return collected;\n        case \"OrExpression\":\n          matched = this.visit(node.children[0], value);\n          if (isFalse(matched)) {\n            matched = this.visit(node.children[1], value);\n          }\n          return matched;\n        case \"AndExpression\":\n          first = this.visit(node.children[0], value);\n          if (isFalse(first) === true) {\n            return first;\n          }\n          return this.visit(node.children[1], value);\n        case \"NotExpression\":\n          first = this.visit(node.children[0], value);\n          return isFalse(first);\n        case \"Literal\":\n          return node.value;\n        case TOK_PIPE:\n          left = this.visit(node.children[0], value);\n          return this.visit(node.children[1], left);\n        case TOK_CURRENT:\n          return value;\n        case \"Function\":\n          var resolvedArgs = [];\n          for (i = 0; i < node.children.length; i++) {\n            resolvedArgs.push(this.visit(node.children[i], value));\n          }\n          return this.runtime.callFunction(node.name, resolvedArgs);\n        case \"ExpressionReference\":\n          var refNode = node.children[0];\n          // Tag the node with a specific attribute so the type\n          // checker verify the type.\n          refNode.jmespathType = TOK_EXPREF;\n          return refNode;\n        default:\n          throw new Error(\"Unknown node type: \" + node.type);\n      }\n    },\n    computeSliceParams: function (arrayLength, sliceParams) {\n      var start = sliceParams[0];\n      var stop = sliceParams[1];\n      var step = sliceParams[2];\n      var computed = [null, null, null];\n      if (step === null) {\n        step = 1;\n      } else if (step === 0) {\n        var error = new Error(\"Invalid slice, step cannot be 0\");\n        error.name = \"RuntimeError\";\n        throw error;\n      }\n      var stepValueNegative = step < 0 ? true : false;\n      if (start === null) {\n        start = stepValueNegative ? arrayLength - 1 : 0;\n      } else {\n        start = this.capSliceRange(arrayLength, start, step);\n      }\n      if (stop === null) {\n        stop = stepValueNegative ? -1 : arrayLength;\n      } else {\n        stop = this.capSliceRange(arrayLength, stop, step);\n      }\n      computed[0] = start;\n      computed[1] = stop;\n      computed[2] = step;\n      return computed;\n    },\n    capSliceRange: function (arrayLength, actualValue, step) {\n      if (actualValue < 0) {\n        actualValue += arrayLength;\n        if (actualValue < 0) {\n          actualValue = step < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLength) {\n        actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n      }\n      return actualValue;\n    }\n  };\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n      // name: [function, <signature>]\n      // The <signature> can be:\n      //\n      // {\n      //   args: [[type1, type2], [type1, type2]],\n      //   variadic: true|false\n      // }\n      //\n      // Each arg in the arg list is a list of valid types\n      // (if the function is overloaded and supports multiple\n      // types.  If the type is \"any\" then no type checking\n      // occurs on the argument.  Variadic is optional\n      // and if not provided is assumed to be false.\n      abs: {\n        _func: this._functionAbs,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      avg: {\n        _func: this._functionAvg,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      ceil: {\n        _func: this._functionCeil,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      contains: {\n        _func: this._functionContains,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }, {\n          types: [TYPE_ANY]\n        }]\n      },\n      \"ends_with\": {\n        _func: this._functionEndsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      floor: {\n        _func: this._functionFloor,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      length: {\n        _func: this._functionLength,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]\n        }]\n      },\n      map: {\n        _func: this._functionMap,\n        _signature: [{\n          types: [TYPE_EXPREF]\n        }, {\n          types: [TYPE_ARRAY]\n        }]\n      },\n      max: {\n        _func: this._functionMax,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"merge\": {\n        _func: this._functionMerge,\n        _signature: [{\n          types: [TYPE_OBJECT],\n          variadic: true\n        }]\n      },\n      \"max_by\": {\n        _func: this._functionMaxBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      sum: {\n        _func: this._functionSum,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"starts_with\": {\n        _func: this._functionStartsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      min: {\n        _func: this._functionMin,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"min_by\": {\n        _func: this._functionMinBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      type: {\n        _func: this._functionType,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      keys: {\n        _func: this._functionKeys,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      values: {\n        _func: this._functionValues,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      sort: {\n        _func: this._functionSort,\n        _signature: [{\n          types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"sort_by\": {\n        _func: this._functionSortBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      join: {\n        _func: this._functionJoin,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_ARRAY_STRING]\n        }]\n      },\n      reverse: {\n        _func: this._functionReverse,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }]\n      },\n      \"to_array\": {\n        _func: this._functionToArray,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_string\": {\n        _func: this._functionToString,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_number\": {\n        _func: this._functionToNumber,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"not_null\": {\n        _func: this._functionNotNull,\n        _signature: [{\n          types: [TYPE_ANY],\n          variadic: true\n        }]\n      }\n    };\n  }\n  Runtime.prototype = {\n    callFunction: function (name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n        throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n    _validateArgs: function (name, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      var pluralized;\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n          throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes at least\" + signature.length + pluralized + \" but received \" + args.length);\n        }\n      } else if (args.length !== signature.length) {\n        pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n        throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes \" + signature.length + pluralized + \" but received \" + args.length);\n      }\n      var currentSpec;\n      var actualType;\n      var typeMatched;\n      for (var i = 0; i < signature.length; i++) {\n        typeMatched = false;\n        currentSpec = signature[i].types;\n        actualType = this._getTypeName(args[i]);\n        for (var j = 0; j < currentSpec.length; j++) {\n          if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n            typeMatched = true;\n            break;\n          }\n        }\n        if (!typeMatched) {\n          var expected = currentSpec.map(function (typeIdentifier) {\n            return TYPE_NAME_TABLE[typeIdentifier];\n          }).join(',');\n          throw new Error(\"TypeError: \" + name + \"() \" + \"expected argument \" + (i + 1) + \" to be type \" + expected + \" but received type \" + TYPE_NAME_TABLE[actualType] + \" instead.\");\n        }\n      }\n    },\n    _typeMatches: function (actual, expected, argValue) {\n      if (expected === TYPE_ANY) {\n        return true;\n      }\n      if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {\n        // The expected type can either just be array,\n        // or it can require a specific subtype (array of numbers).\n        //\n        // The simplest case is if \"array\" with no subtype is specified.\n        if (expected === TYPE_ARRAY) {\n          return actual === TYPE_ARRAY;\n        } else if (actual === TYPE_ARRAY) {\n          // Otherwise we need to check subtypes.\n          // I think this has potential to be improved.\n          var subtype;\n          if (expected === TYPE_ARRAY_NUMBER) {\n            subtype = TYPE_NUMBER;\n          } else if (expected === TYPE_ARRAY_STRING) {\n            subtype = TYPE_STRING;\n          }\n          for (var i = 0; i < argValue.length; i++) {\n            if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n      } else {\n        return actual === expected;\n      }\n    },\n    _getTypeName: function (obj) {\n      switch (Object.prototype.toString.call(obj)) {\n        case \"[object String]\":\n          return TYPE_STRING;\n        case \"[object Number]\":\n          return TYPE_NUMBER;\n        case \"[object Array]\":\n          return TYPE_ARRAY;\n        case \"[object Boolean]\":\n          return TYPE_BOOLEAN;\n        case \"[object Null]\":\n          return TYPE_NULL;\n        case \"[object Object]\":\n          // Check if it's an expref.  If it has, it's been\n          // tagged with a jmespathType attr of 'Expref';\n          if (obj.jmespathType === TOK_EXPREF) {\n            return TYPE_EXPREF;\n          } else {\n            return TYPE_OBJECT;\n          }\n      }\n    },\n    _functionStartsWith: function (resolvedArgs) {\n      return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n    _functionEndsWith: function (resolvedArgs) {\n      var searchStr = resolvedArgs[0];\n      var suffix = resolvedArgs[1];\n      return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n    _functionReverse: function (resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n      if (typeName === TYPE_STRING) {\n        var originalStr = resolvedArgs[0];\n        var reversedStr = \"\";\n        for (var i = originalStr.length - 1; i >= 0; i--) {\n          reversedStr += originalStr[i];\n        }\n        return reversedStr;\n      } else {\n        var reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      }\n    },\n    _functionAbs: function (resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n    _functionCeil: function (resolvedArgs) {\n      return Math.ceil(resolvedArgs[0]);\n    },\n    _functionAvg: function (resolvedArgs) {\n      var sum = 0;\n      var inputArray = resolvedArgs[0];\n      for (var i = 0; i < inputArray.length; i++) {\n        sum += inputArray[i];\n      }\n      return sum / inputArray.length;\n    },\n    _functionContains: function (resolvedArgs) {\n      return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n    _functionFloor: function (resolvedArgs) {\n      return Math.floor(resolvedArgs[0]);\n    },\n    _functionLength: function (resolvedArgs) {\n      if (!isObject(resolvedArgs[0])) {\n        return resolvedArgs[0].length;\n      } else {\n        // As far as I can tell, there's no way to get the length\n        // of an object without O(n) iteration through the object.\n        return Object.keys(resolvedArgs[0]).length;\n      }\n    },\n    _functionMap: function (resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n        mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n    _functionMerge: function (resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n    _functionMax: function (resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n            if (maxElement.localeCompare(elements[i]) < 0) {\n              maxElement = elements[i];\n            }\n          }\n          return maxElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionMin: function (resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n            if (elements[i].localeCompare(minElement) < 0) {\n              minElement = elements[i];\n            }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionSum: function (resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n    _functionType: function (resolvedArgs) {\n      switch (this._getTypeName(resolvedArgs[0])) {\n        case TYPE_NUMBER:\n          return \"number\";\n        case TYPE_STRING:\n          return \"string\";\n        case TYPE_ARRAY:\n          return \"array\";\n        case TYPE_OBJECT:\n          return \"object\";\n        case TYPE_BOOLEAN:\n          return \"boolean\";\n        case TYPE_EXPREF:\n          return \"expref\";\n        case TYPE_NULL:\n          return \"null\";\n      }\n    },\n    _functionKeys: function (resolvedArgs) {\n      return Object.keys(resolvedArgs[0]);\n    },\n    _functionValues: function (resolvedArgs) {\n      var obj = resolvedArgs[0];\n      var keys = Object.keys(obj);\n      var values = [];\n      for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n      }\n      return values;\n    },\n    _functionJoin: function (resolvedArgs) {\n      var joinChar = resolvedArgs[0];\n      var listJoin = resolvedArgs[1];\n      return listJoin.join(joinChar);\n    },\n    _functionToArray: function (resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n        return resolvedArgs[0];\n      } else {\n        return [resolvedArgs[0]];\n      }\n    },\n    _functionToString: function (resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n        return resolvedArgs[0];\n      } else {\n        return JSON.stringify(resolvedArgs[0]);\n      }\n    },\n    _functionToNumber: function (resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n      var convertedValue;\n      if (typeName === TYPE_NUMBER) {\n        return resolvedArgs[0];\n      } else if (typeName === TYPE_STRING) {\n        convertedValue = +resolvedArgs[0];\n        if (!isNaN(convertedValue)) {\n          return convertedValue;\n        }\n      }\n      return null;\n    },\n    _functionNotNull: function (resolvedArgs) {\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n          return resolvedArgs[i];\n        }\n      }\n      return null;\n    },\n    _functionSort: function (resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n      sortedArray.sort();\n      return sortedArray;\n    },\n    _functionSortBy: function (resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n      if (sortedArray.length === 0) {\n        return sortedArray;\n      }\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[1];\n      var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));\n      if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n        throw new Error(\"TypeError\");\n      }\n      var that = this;\n      // In order to get a stable sort out of an unstable\n      // sort algorithm, we decorate/sort/undecorate (DSU)\n      // by creating a new list of [index, element] pairs.\n      // In the cmp function, if the evaluated elements are\n      // equal, then the index will be used as the tiebreaker.\n      // After the decorated list has been sorted, it will be\n      // undecorated to extract the original elements.\n      var decorated = [];\n      for (var i = 0; i < sortedArray.length; i++) {\n        decorated.push([i, sortedArray[i]]);\n      }\n      decorated.sort(function (a, b) {\n        var exprA = interpreter.visit(exprefNode, a[1]);\n        var exprB = interpreter.visit(exprefNode, b[1]);\n        if (that._getTypeName(exprA) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprA));\n        } else if (that._getTypeName(exprB) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprB));\n        }\n        if (exprA > exprB) {\n          return 1;\n        } else if (exprA < exprB) {\n          return -1;\n        } else {\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        }\n      });\n      // Undecorate: extract out the original list elements.\n      for (var j = 0; j < decorated.length; j++) {\n        sortedArray[j] = decorated[j][1];\n      }\n      return sortedArray;\n    },\n    _functionMaxBy: function (resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n    _functionMinBy: function (resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n    createKeyFunction: function (exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function (x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes + \", received \" + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n  };\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n  function tokenize(stream) {\n    var lexer = new Lexer();\n    return lexer.tokenize(stream);\n  }\n  function search(data, expression) {\n    var parser = new Parser();\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n  }\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}