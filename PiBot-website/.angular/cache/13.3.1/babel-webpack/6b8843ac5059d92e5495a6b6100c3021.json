{"ast":null,"code":"var AWS = require('../core'),\n    url = AWS.util.url,\n    crypto = AWS.util.crypto.lib,\n    base64Encode = AWS.util.base64.encode,\n    inherit = AWS.util.inherit;\n\nvar queryEncode = function (string) {\n  var replacements = {\n    '+': '-',\n    '=': '_',\n    '/': '~'\n  };\n  return string.replace(/[\\+=\\/]/g, function (match) {\n    return replacements[match];\n  });\n};\n\nvar signPolicy = function (policy, privateKey) {\n  var sign = crypto.createSign('RSA-SHA1');\n  sign.write(policy);\n  return queryEncode(sign.sign(privateKey, 'base64'));\n};\n\nvar signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {\n  var policy = JSON.stringify({\n    Statement: [{\n      Resource: url,\n      Condition: {\n        DateLessThan: {\n          'AWS:EpochTime': expires\n        }\n      }\n    }]\n  });\n  return {\n    Expires: expires,\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy.toString(), privateKey)\n  };\n};\n\nvar signWithCustomPolicy = function (policy, keyPairId, privateKey) {\n  policy = policy.replace(/\\s/mg, '');\n  return {\n    Policy: queryEncode(base64Encode(policy)),\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy, privateKey)\n  };\n};\n\nvar determineScheme = function (url) {\n  var parts = url.split('://');\n\n  if (parts.length < 2) {\n    throw new Error('Invalid URL.');\n  }\n\n  return parts[0].replace('*', '');\n};\n\nvar getRtmpUrl = function (rtmpUrl) {\n  var parsed = url.parse(rtmpUrl);\n  return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\n};\n\nvar getResource = function (url) {\n  switch (determineScheme(url)) {\n    case 'http':\n    case 'https':\n      return url;\n\n    case 'rtmp':\n      return getRtmpUrl(url);\n\n    default:\n      throw new Error('Invalid URI scheme. Scheme must be one of' + ' http, https, or rtmp');\n  }\n};\n\nvar handleError = function (err, callback) {\n  if (!callback || typeof callback !== 'function') {\n    throw err;\n  }\n\n  callback(err);\n};\n\nvar handleSuccess = function (result, callback) {\n  if (!callback || typeof callback !== 'function') {\n    return result;\n  }\n\n  callback(null, result);\n};\n\nAWS.CloudFront.Signer = inherit({\n  /**\n   * A signer object can be used to generate signed URLs and cookies for granting\n   * access to content on restricted CloudFront distributions.\n   *\n   * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\n   *\n   * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\n   *                              being used.\n   * @param privateKey [String]   (Required) A private key in RSA format.\n   */\n  constructor: function Signer(keyPairId, privateKey) {\n    if (keyPairId === void 0 || privateKey === void 0) {\n      throw new Error('A key pair ID and private key are required');\n    }\n\n    this.keyPairId = keyPairId;\n    this.privateKey = privateKey;\n  },\n\n  /**\n   * Create a signed Amazon CloudFront Cookie.\n   *\n   * @param options [Object]            The options to create a signed cookie.\n   * @option options url [String]     The URL to which the signature will grant\n   *                                  access. Required unless you pass in a full\n   *                                  policy.\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\n   *                                  signature should expire. Required unless you\n   *                                  pass in a full policy.\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\n   *                                  you pass in a url and an expiry time.\n   *\n   * @param cb [Function] if a callback is provided, this function will\n   *   pass the hash as the second parameter (after the error parameter) to\n   *   the callback function.\n   *\n   * @return [Object] if called synchronously (with no callback), returns the\n   *   signed cookie parameters.\n   * @return [null] nothing is returned if a callback is provided.\n   */\n  getSignedCookie: function (options, cb) {\n    var signatureHash = 'policy' in options ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\n    var cookieHash = {};\n\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        cookieHash['CloudFront-' + key] = signatureHash[key];\n      }\n    }\n\n    return handleSuccess(cookieHash, cb);\n  },\n\n  /**\n   * Create a signed Amazon CloudFront URL.\n   *\n   * Keep in mind that URLs meant for use in media/flash players may have\n   * different requirements for URL formats (e.g. some require that the\n   * extension be removed, some require the file name to be prefixed\n   * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\n   *\n   * @param options [Object]          The options to create a signed URL.\n   * @option options url [String]     The URL to which the signature will grant\n   *                                  access. Any query params included with\n   *                                  the URL should be encoded. Required.\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\n   *                                  signature should expire. Required unless you\n   *                                  pass in a full policy.\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\n   *                                  you pass in a url and an expiry time.\n   *\n   * @param cb [Function] if a callback is provided, this function will\n   *   pass the URL as the second parameter (after the error parameter) to\n   *   the callback function.\n   *\n   * @return [String] if called synchronously (with no callback), returns the\n   *   signed URL.\n   * @return [null] nothing is returned if a callback is provided.\n   */\n  getSignedUrl: function (options, cb) {\n    try {\n      var resource = getResource(options.url);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n\n    var parsedUrl = url.parse(options.url, true),\n        signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy') ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\n    parsedUrl.search = null;\n\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        parsedUrl.query[key] = signatureHash[key];\n      }\n    }\n\n    try {\n      var signedUrl = determineScheme(options.url) === 'rtmp' ? getRtmpUrl(url.format(parsedUrl)) : url.format(parsedUrl);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n\n    return handleSuccess(signedUrl, cb);\n  }\n});\n/**\n * @api private\n */\n\nmodule.exports = AWS.CloudFront.Signer;","map":null,"metadata":{},"sourceType":"script"}